<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game</title>
    <style>
        canvas {
            background: #f0f0f0;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let hero = { x: canvas.width / 2, y: canvas.height / 2, size: 20 };
        let spectators = [];
        let enemy1 = null;
        let enemy2 = null;
        let followingSpectator1 = null;
        let followingSpectator2 = null;
        let nonCollidedSpectators = 0;
        let heroCollisionCounter = 3;
        let topScore = 0;
        let requestAnimationFrameHandle;

        // Адаптивный размер canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            hero.x = canvas.width / 2;
            hero.y = canvas.height / 2;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function createSpectator() {
            let spectator = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: 10,
                color: 'red',
                speed: 1
            };
            spectators.push(spectator);
        }

        function initializeSpectators(count) {
            for (let i = 0; i < count; i++) {
                createSpectator();
            }
        }

        function createEnemy1() {
            enemy1 = { x: 0, y: 0, size: 20, color: 'blue' };
        }

        function createEnemy2() {
            enemy2 = { x: canvas.width, y: canvas.height, size: 20, color: 'purple' };
        }

        function drawCircle(obj) {
            if (obj) {
                ctx.fillStyle = obj.color;
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawHero() {
            drawCircle(hero);
        }

        function drawSpectators() {
            spectators.forEach(spectator => {
                drawCircle(spectator);
            });
        }

        function drawEnemies() {
            drawCircle(enemy1);
            drawCircle(enemy2);
        }

        function updateHeroPosition() {
            window.addEventListener('keydown', function (e) {
                if (e.key === 'ArrowUp') hero.y -= 10;
                if (e.key === 'ArrowDown') hero.y += 10;
                if (e.key === 'ArrowLeft') hero.x -= 10;
                if (e.key === 'ArrowRight') hero.x += 10;
            });
        }

        function updateHeroPositionTouch() {
            canvas.addEventListener('touchstart', function (e) {
                let touch = e.touches[0];
                hero.x = touch.clientX;
                hero.y = touch.clientY;
            });
        }

        function checkCollision(obj1, obj2) {
            let dx = obj1.x - obj2.x;
            let dy = obj1.y - obj2.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            return distance < obj1.size + obj2.size;
        }

        function updateHeroCollisionCounter() {
            spectators.forEach(spectator => {
                if (checkCollision(hero, spectator) && spectator.color !== 'green') {
                    spectator.color = 'green';
                    nonCollidedSpectators++;
                }
            });

            [enemy1, enemy2].forEach(enemy => {
                if (enemy && checkCollision(hero, enemy)) {
                    heroCollisionCounter--;
                }
            });
        }

        function followSpectator(enemy, followingSpectator) {
            if (followingSpectator && followingSpectator.color !== 'green') {
                enemy.x = followingSpectator.x;
                enemy.y = followingSpectator.y;
            }
        }

        function gameOver() {
            cancelAnimationFrame(requestAnimationFrameHandle);
            topScore = nonCollidedSpectators;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.font = "30px Arial";
            ctx.fillText(`Game Over`, canvas.width / 2 - 70, canvas.height / 2);
            ctx.fillText(`TopScore: ${topScore}`, canvas.width / 2 - 90, canvas.height / 2 + 40);
        }

        function updateGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawHero();
            drawSpectators();
            drawEnemies();
            updateHeroCollisionCounter();

            if (spectators.every(s => s.color === 'green') || heroCollisionCounter <= 0) {
                gameOver();
                return;
            }

            if (nonCollidedSpectators >= 2 && !enemy1) {
                createEnemy1();
                console.log("Enemy1 created!");
            }

            if (nonCollidedSpectators >= 4 && !enemy2) {
                createEnemy2();
                console.log("Enemy2 created!");
            }

            if (enemy1) {
                followingSpectator1 = spectators.find(s => checkCollision(s, enemy1) && s.color !== 'green');
                followSpectator(enemy1, followingSpectator1);
            }

            if (enemy2) {
                followingSpectator2 = spectators.find(s => checkCollision(s, enemy2) && s.color !== 'green');
                followSpectator(enemy2, followingSpectator2);
            }

            requestAnimationFrameHandle = requestAnimationFrame(updateGame);
        }

        function gameLoop() {
            updateHeroPosition();
            updateHeroPositionTouch();
            updateGame();
        }

        initializeSpectators(10);
        gameLoop();
    </script>
</body>

</html>
